import { ISourceCode, ISourceLocation } from '@src/model/sourceCode';

/**
 * Reprresent single stack frame in stack trace
 */
interface IBacktraceStackFrame {
  funcName: string;
  sourceCode: string;
  library: string;
  line: number;
  column: number;
}

/**
 * Analyse stack trace generated by exception
 * Create Stack Frames and find calling library/program informaiton
 */
export class BacktraceStackTrace {
  public readonly fault: boolean = true;
  public readonly name = 'main';
  public stack: IBacktraceStackFrame[] = [];

  public sourceCodeInformation: { [index: string]: ISourceCode } = {};
  private readonly stackLineRe = /\s+at (.+) \((.+):(\d+):(\d+)\)/;
  private requestedSourceCode: { [index: string]: ISourceLocation[] } = {};

  private tabWidth: number = 8;
  private contextLineCount: number = 200;

  private error: Error;
  constructor(err: Error | string) {
    // handle reports with message
    if (!(err instanceof Error)) {
      err = new Error();
    }
    this.error = err;
  }

  public setSourceCodeOptions(tabWidth: number, contextLineCount: number) {
    this.tabWidth = tabWidth;
    this.contextLineCount = contextLineCount;
  }

  /**
   * Get Json data from Stack trace object
   */
  public toJson() {
    return {
      name: this.name,
      fault: this.fault,
      stack: this.stack,
    };
  }

  /**
   * Get source code information
   */
  public getSourceCode(): { [index: string]: ISourceCode } {
    return this.sourceCodeInformation;
  }

  /**
   * Start parsing stack frames
   */
  public async parseStackFrames(): Promise<void> {
    const stackTrace = this.error.stack;
    if (!stackTrace) {
      return;
    }
    // get exception lines and remove first line of descrtiption
    const lines = stackTrace.split('\n').slice(1);
    lines.forEach((line) => {
      const match = line.match(this.stackLineRe);
      if (!match || match.length < 4) {
        return;
      }
      const backtraceLibStackFrame = match[2].indexOf('node_modules/backtrace-node') !== -1;
      if (backtraceLibStackFrame) {
        return;
      }

      const stackFrame = {
        funcName: match[1],
        sourceCode: match[2],
        library: match[2],
        line: parseInt(match[3], 10),
        column: parseInt(match[4], 10),
      };

      this.addSourceRequest(stackFrame);
      this.stack.push(stackFrame);
    });
  }

  private addSourceRequest(stackFrame: IBacktraceStackFrame): void {
    // add source code to existing list. Otherwise create empty array
    this.requestedSourceCode[stackFrame.sourceCode] = this.requestedSourceCode[stackFrame.sourceCode] || [];
    this.requestedSourceCode[stackFrame.sourceCode].push({
      line: stackFrame.line,
      column: stackFrame.column,
    });
  }
}
